
blink_CM0PLUS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08020000  08020000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000007a8  080200c0  080200c0  000010c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000080  08020868  08020868  00001868  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080208e8  080208e8  0000200c  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  080208e8  080208e8  0000200c  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  080208e8  080208e8  0000200c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080208e8  080208e8  000018e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  080208ec  080208ec  000018ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         0000000c  20008000  080208f0  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000020  2000800c  080208fc  0000200c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000802c  080208fc  0000202c  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  0000200c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00003c3b  00000000  00000000  00002034  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00000d1c  00000000  00000000  00005c6f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000670  00000000  00000000  00006990  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 000004b7  00000000  00000000  00007000  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0001b4a9  00000000  00000000  000074b7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   0000576e  00000000  00000000  00022960  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    000ae28a  00000000  00000000  000280ce  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  000d6358  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000015c0  00000000  00000000  000d639c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 0000006d  00000000  00000000  000d795c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080200c0 <__do_global_dtors_aux>:
 80200c0:	b510      	push	{r4, lr}
 80200c2:	4c06      	ldr	r4, [pc, #24]	@ (80200dc <__do_global_dtors_aux+0x1c>)
 80200c4:	7823      	ldrb	r3, [r4, #0]
 80200c6:	2b00      	cmp	r3, #0
 80200c8:	d107      	bne.n	80200da <__do_global_dtors_aux+0x1a>
 80200ca:	4b05      	ldr	r3, [pc, #20]	@ (80200e0 <__do_global_dtors_aux+0x20>)
 80200cc:	2b00      	cmp	r3, #0
 80200ce:	d002      	beq.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d0:	4804      	ldr	r0, [pc, #16]	@ (80200e4 <__do_global_dtors_aux+0x24>)
 80200d2:	e000      	b.n	80200d6 <__do_global_dtors_aux+0x16>
 80200d4:	bf00      	nop
 80200d6:	2301      	movs	r3, #1
 80200d8:	7023      	strb	r3, [r4, #0]
 80200da:	bd10      	pop	{r4, pc}
 80200dc:	2000800c 	.word	0x2000800c
 80200e0:	00000000 	.word	0x00000000
 80200e4:	08020850 	.word	0x08020850

080200e8 <frame_dummy>:
 80200e8:	4b04      	ldr	r3, [pc, #16]	@ (80200fc <frame_dummy+0x14>)
 80200ea:	b510      	push	{r4, lr}
 80200ec:	2b00      	cmp	r3, #0
 80200ee:	d003      	beq.n	80200f8 <frame_dummy+0x10>
 80200f0:	4903      	ldr	r1, [pc, #12]	@ (8020100 <frame_dummy+0x18>)
 80200f2:	4804      	ldr	r0, [pc, #16]	@ (8020104 <frame_dummy+0x1c>)
 80200f4:	e000      	b.n	80200f8 <frame_dummy+0x10>
 80200f6:	bf00      	nop
 80200f8:	bd10      	pop	{r4, pc}
 80200fa:	46c0      	nop			@ (mov r8, r8)
 80200fc:	00000000 	.word	0x00000000
 8020100:	20008010 	.word	0x20008010
 8020104:	08020850 	.word	0x08020850

08020108 <__udivsi3>:
 8020108:	2200      	movs	r2, #0
 802010a:	0843      	lsrs	r3, r0, #1
 802010c:	428b      	cmp	r3, r1
 802010e:	d374      	bcc.n	80201fa <__udivsi3+0xf2>
 8020110:	0903      	lsrs	r3, r0, #4
 8020112:	428b      	cmp	r3, r1
 8020114:	d35f      	bcc.n	80201d6 <__udivsi3+0xce>
 8020116:	0a03      	lsrs	r3, r0, #8
 8020118:	428b      	cmp	r3, r1
 802011a:	d344      	bcc.n	80201a6 <__udivsi3+0x9e>
 802011c:	0b03      	lsrs	r3, r0, #12
 802011e:	428b      	cmp	r3, r1
 8020120:	d328      	bcc.n	8020174 <__udivsi3+0x6c>
 8020122:	0c03      	lsrs	r3, r0, #16
 8020124:	428b      	cmp	r3, r1
 8020126:	d30d      	bcc.n	8020144 <__udivsi3+0x3c>
 8020128:	22ff      	movs	r2, #255	@ 0xff
 802012a:	0209      	lsls	r1, r1, #8
 802012c:	ba12      	rev	r2, r2
 802012e:	0c03      	lsrs	r3, r0, #16
 8020130:	428b      	cmp	r3, r1
 8020132:	d302      	bcc.n	802013a <__udivsi3+0x32>
 8020134:	1212      	asrs	r2, r2, #8
 8020136:	0209      	lsls	r1, r1, #8
 8020138:	d065      	beq.n	8020206 <__udivsi3+0xfe>
 802013a:	0b03      	lsrs	r3, r0, #12
 802013c:	428b      	cmp	r3, r1
 802013e:	d319      	bcc.n	8020174 <__udivsi3+0x6c>
 8020140:	e000      	b.n	8020144 <__udivsi3+0x3c>
 8020142:	0a09      	lsrs	r1, r1, #8
 8020144:	0bc3      	lsrs	r3, r0, #15
 8020146:	428b      	cmp	r3, r1
 8020148:	d301      	bcc.n	802014e <__udivsi3+0x46>
 802014a:	03cb      	lsls	r3, r1, #15
 802014c:	1ac0      	subs	r0, r0, r3
 802014e:	4152      	adcs	r2, r2
 8020150:	0b83      	lsrs	r3, r0, #14
 8020152:	428b      	cmp	r3, r1
 8020154:	d301      	bcc.n	802015a <__udivsi3+0x52>
 8020156:	038b      	lsls	r3, r1, #14
 8020158:	1ac0      	subs	r0, r0, r3
 802015a:	4152      	adcs	r2, r2
 802015c:	0b43      	lsrs	r3, r0, #13
 802015e:	428b      	cmp	r3, r1
 8020160:	d301      	bcc.n	8020166 <__udivsi3+0x5e>
 8020162:	034b      	lsls	r3, r1, #13
 8020164:	1ac0      	subs	r0, r0, r3
 8020166:	4152      	adcs	r2, r2
 8020168:	0b03      	lsrs	r3, r0, #12
 802016a:	428b      	cmp	r3, r1
 802016c:	d301      	bcc.n	8020172 <__udivsi3+0x6a>
 802016e:	030b      	lsls	r3, r1, #12
 8020170:	1ac0      	subs	r0, r0, r3
 8020172:	4152      	adcs	r2, r2
 8020174:	0ac3      	lsrs	r3, r0, #11
 8020176:	428b      	cmp	r3, r1
 8020178:	d301      	bcc.n	802017e <__udivsi3+0x76>
 802017a:	02cb      	lsls	r3, r1, #11
 802017c:	1ac0      	subs	r0, r0, r3
 802017e:	4152      	adcs	r2, r2
 8020180:	0a83      	lsrs	r3, r0, #10
 8020182:	428b      	cmp	r3, r1
 8020184:	d301      	bcc.n	802018a <__udivsi3+0x82>
 8020186:	028b      	lsls	r3, r1, #10
 8020188:	1ac0      	subs	r0, r0, r3
 802018a:	4152      	adcs	r2, r2
 802018c:	0a43      	lsrs	r3, r0, #9
 802018e:	428b      	cmp	r3, r1
 8020190:	d301      	bcc.n	8020196 <__udivsi3+0x8e>
 8020192:	024b      	lsls	r3, r1, #9
 8020194:	1ac0      	subs	r0, r0, r3
 8020196:	4152      	adcs	r2, r2
 8020198:	0a03      	lsrs	r3, r0, #8
 802019a:	428b      	cmp	r3, r1
 802019c:	d301      	bcc.n	80201a2 <__udivsi3+0x9a>
 802019e:	020b      	lsls	r3, r1, #8
 80201a0:	1ac0      	subs	r0, r0, r3
 80201a2:	4152      	adcs	r2, r2
 80201a4:	d2cd      	bcs.n	8020142 <__udivsi3+0x3a>
 80201a6:	09c3      	lsrs	r3, r0, #7
 80201a8:	428b      	cmp	r3, r1
 80201aa:	d301      	bcc.n	80201b0 <__udivsi3+0xa8>
 80201ac:	01cb      	lsls	r3, r1, #7
 80201ae:	1ac0      	subs	r0, r0, r3
 80201b0:	4152      	adcs	r2, r2
 80201b2:	0983      	lsrs	r3, r0, #6
 80201b4:	428b      	cmp	r3, r1
 80201b6:	d301      	bcc.n	80201bc <__udivsi3+0xb4>
 80201b8:	018b      	lsls	r3, r1, #6
 80201ba:	1ac0      	subs	r0, r0, r3
 80201bc:	4152      	adcs	r2, r2
 80201be:	0943      	lsrs	r3, r0, #5
 80201c0:	428b      	cmp	r3, r1
 80201c2:	d301      	bcc.n	80201c8 <__udivsi3+0xc0>
 80201c4:	014b      	lsls	r3, r1, #5
 80201c6:	1ac0      	subs	r0, r0, r3
 80201c8:	4152      	adcs	r2, r2
 80201ca:	0903      	lsrs	r3, r0, #4
 80201cc:	428b      	cmp	r3, r1
 80201ce:	d301      	bcc.n	80201d4 <__udivsi3+0xcc>
 80201d0:	010b      	lsls	r3, r1, #4
 80201d2:	1ac0      	subs	r0, r0, r3
 80201d4:	4152      	adcs	r2, r2
 80201d6:	08c3      	lsrs	r3, r0, #3
 80201d8:	428b      	cmp	r3, r1
 80201da:	d301      	bcc.n	80201e0 <__udivsi3+0xd8>
 80201dc:	00cb      	lsls	r3, r1, #3
 80201de:	1ac0      	subs	r0, r0, r3
 80201e0:	4152      	adcs	r2, r2
 80201e2:	0883      	lsrs	r3, r0, #2
 80201e4:	428b      	cmp	r3, r1
 80201e6:	d301      	bcc.n	80201ec <__udivsi3+0xe4>
 80201e8:	008b      	lsls	r3, r1, #2
 80201ea:	1ac0      	subs	r0, r0, r3
 80201ec:	4152      	adcs	r2, r2
 80201ee:	0843      	lsrs	r3, r0, #1
 80201f0:	428b      	cmp	r3, r1
 80201f2:	d301      	bcc.n	80201f8 <__udivsi3+0xf0>
 80201f4:	004b      	lsls	r3, r1, #1
 80201f6:	1ac0      	subs	r0, r0, r3
 80201f8:	4152      	adcs	r2, r2
 80201fa:	1a41      	subs	r1, r0, r1
 80201fc:	d200      	bcs.n	8020200 <__udivsi3+0xf8>
 80201fe:	4601      	mov	r1, r0
 8020200:	4152      	adcs	r2, r2
 8020202:	4610      	mov	r0, r2
 8020204:	4770      	bx	lr
 8020206:	e7ff      	b.n	8020208 <__udivsi3+0x100>
 8020208:	b501      	push	{r0, lr}
 802020a:	2000      	movs	r0, #0
 802020c:	f000 f806 	bl	802021c <__aeabi_idiv0>
 8020210:	bd02      	pop	{r1, pc}
 8020212:	46c0      	nop			@ (mov r8, r8)

08020214 <__aeabi_uidivmod>:
 8020214:	2900      	cmp	r1, #0
 8020216:	d0f7      	beq.n	8020208 <__udivsi3+0x100>
 8020218:	e776      	b.n	8020108 <__udivsi3>
 802021a:	4770      	bx	lr

0802021c <__aeabi_idiv0>:
 802021c:	4770      	bx	lr
 802021e:	46c0      	nop			@ (mov r8, r8)

08020220 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8020220:	b580      	push	{r7, lr}
 8020222:	af00      	add	r7, sp, #0

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << (10UL*2UL))|(3UL << (11UL*2UL)));  /* set CP10 and CP11 Full Access */
#endif
}
 8020224:	46c0      	nop			@ (mov r8, r8)
 8020226:	46bd      	mov	sp, r7
 8020228:	bd80      	pop	{r7, pc}

0802022a <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 802022a:	b580      	push	{r7, lr}
 802022c:	af00      	add	r7, sp, #0
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 802022e:	f000 f84b 	bl	80202c8 <HAL_Init>

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8020232:	46c0      	nop			@ (mov r8, r8)
 8020234:	e7fd      	b.n	8020232 <main+0x8>

08020236 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8020236:	b580      	push	{r7, lr}
 8020238:	af00      	add	r7, sp, #0
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 802023a:	46c0      	nop			@ (mov r8, r8)
 802023c:	46bd      	mov	sp, r7
 802023e:	bd80      	pop	{r7, pc}

08020240 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable Interrupt.
  */
void NMI_Handler(void)
{
 8020240:	b580      	push	{r7, lr}
 8020242:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8020244:	46c0      	nop			@ (mov r8, r8)
 8020246:	e7fd      	b.n	8020244 <NMI_Handler+0x4>

08020248 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8020248:	b580      	push	{r7, lr}
 802024a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 802024c:	46c0      	nop			@ (mov r8, r8)
 802024e:	e7fd      	b.n	802024c <HardFault_Handler+0x4>

08020250 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8020250:	b580      	push	{r7, lr}
 8020252:	af00      	add	r7, sp, #0

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 8020254:	46c0      	nop			@ (mov r8, r8)
 8020256:	46bd      	mov	sp, r7
 8020258:	bd80      	pop	{r7, pc}

0802025a <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 802025a:	b580      	push	{r7, lr}
 802025c:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 802025e:	46c0      	nop			@ (mov r8, r8)
 8020260:	46bd      	mov	sp, r7
 8020262:	bd80      	pop	{r7, pc}

08020264 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8020264:	b580      	push	{r7, lr}
 8020266:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8020268:	f000 f898 	bl	802039c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 802026c:	46c0      	nop			@ (mov r8, r8)
 802026e:	46bd      	mov	sp, r7
 8020270:	bd80      	pop	{r7, pc}
	...

08020274 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8020274:	480d      	ldr	r0, [pc, #52]	@ (80202ac <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8020276:	4685      	mov	sp, r0

/* Call the clock system initialization function.*/
  bl  SystemInit
 8020278:	f7ff ffd2 	bl	8020220 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 802027c:	480c      	ldr	r0, [pc, #48]	@ (80202b0 <LoopForever+0x6>)
  ldr r1, =_edata
 802027e:	490d      	ldr	r1, [pc, #52]	@ (80202b4 <LoopForever+0xa>)
  ldr r2, =_sidata
 8020280:	4a0d      	ldr	r2, [pc, #52]	@ (80202b8 <LoopForever+0xe>)
  movs r3, #0
 8020282:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8020284:	e002      	b.n	802028c <LoopCopyDataInit>

08020286 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8020286:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8020288:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 802028a:	3304      	adds	r3, #4

0802028c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 802028c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 802028e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8020290:	d3f9      	bcc.n	8020286 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8020292:	4a0a      	ldr	r2, [pc, #40]	@ (80202bc <LoopForever+0x12>)
  ldr r4, =_ebss
 8020294:	4c0a      	ldr	r4, [pc, #40]	@ (80202c0 <LoopForever+0x16>)
  movs r3, #0
 8020296:	2300      	movs	r3, #0
  b LoopFillZerobss
 8020298:	e001      	b.n	802029e <LoopFillZerobss>

0802029a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 802029a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 802029c:	3204      	adds	r2, #4

0802029e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 802029e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80202a0:	d3fb      	bcc.n	802029a <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80202a2:	f000 fab1 	bl	8020808 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80202a6:	f7ff ffc0 	bl	802022a <main>

080202aa <LoopForever>:

LoopForever:
    b LoopForever
 80202aa:	e7fe      	b.n	80202aa <LoopForever>
  ldr   r0, =_estack
 80202ac:	20010000 	.word	0x20010000
  ldr r0, =_sdata
 80202b0:	20008000 	.word	0x20008000
  ldr r1, =_edata
 80202b4:	2000800c 	.word	0x2000800c
  ldr r2, =_sidata
 80202b8:	080208f0 	.word	0x080208f0
  ldr r2, =_sbss
 80202bc:	2000800c 	.word	0x2000800c
  ldr r4, =_ebss
 80202c0:	2000802c 	.word	0x2000802c

080202c4 <ADC_COMP_DAC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80202c4:	e7fe      	b.n	80202c4 <ADC_COMP_DAC_IRQHandler>
	...

080202c8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80202c8:	b580      	push	{r7, lr}
 80202ca:	b082      	sub	sp, #8
 80202cc:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
 80202ce:	1dfb      	adds	r3, r7, #7
 80202d0:	2200      	movs	r2, #0
 80202d2:	701a      	strb	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

#ifdef CORE_CM0PLUS
#else
  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80202d4:	2003      	movs	r0, #3
 80202d6:	f000 f929 	bl	802052c <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(DUAL_CORE) && defined(CORE_CM0PLUS)
  SystemCoreClock = HAL_RCC_GetHCLK2Freq();
#else
  SystemCoreClock = HAL_RCC_GetHCLKFreq();
 80202da:	f000 fa7d 	bl	80207d8 <HAL_RCC_GetHCLKFreq>
 80202de:	0002      	movs	r2, r0
 80202e0:	4b09      	ldr	r3, [pc, #36]	@ (8020308 <HAL_Init+0x40>)
 80202e2:	601a      	str	r2, [r3, #0]
#endif

  /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is MSI) */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80202e4:	2000      	movs	r0, #0
 80202e6:	f000 f811 	bl	802030c <HAL_InitTick>
 80202ea:	1e03      	subs	r3, r0, #0
 80202ec:	d003      	beq.n	80202f6 <HAL_Init+0x2e>
  {
    status = HAL_ERROR;
 80202ee:	1dfb      	adds	r3, r7, #7
 80202f0:	2201      	movs	r2, #1
 80202f2:	701a      	strb	r2, [r3, #0]
 80202f4:	e001      	b.n	80202fa <HAL_Init+0x32>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
 80202f6:	f7ff ff9e 	bl	8020236 <HAL_MspInit>
  }

  /* Return function status */
  return status;
 80202fa:	1dfb      	adds	r3, r7, #7
 80202fc:	781b      	ldrb	r3, [r3, #0]
}
 80202fe:	0018      	movs	r0, r3
 8020300:	46bd      	mov	sp, r7
 8020302:	b002      	add	sp, #8
 8020304:	bd80      	pop	{r7, pc}
 8020306:	46c0      	nop			@ (mov r8, r8)
 8020308:	20008000 	.word	0x20008000

0802030c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 802030c:	b590      	push	{r4, r7, lr}
 802030e:	b085      	sub	sp, #20
 8020310:	af00      	add	r7, sp, #0
 8020312:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
 8020314:	230f      	movs	r3, #15
 8020316:	18fb      	adds	r3, r7, r3
 8020318:	2200      	movs	r2, #0
 802031a:	701a      	strb	r2, [r3, #0]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
 802031c:	4b1d      	ldr	r3, [pc, #116]	@ (8020394 <HAL_InitTick+0x88>)
 802031e:	781b      	ldrb	r3, [r3, #0]
 8020320:	2b00      	cmp	r3, #0
 8020322:	d02c      	beq.n	802037e <HAL_InitTick+0x72>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
#ifdef CORE_CM0PLUS
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLK2Freq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
#else
    if (HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / (1000U / (uint32_t)uwTickFreq)) == 0U)
 8020324:	f000 fa58 	bl	80207d8 <HAL_RCC_GetHCLKFreq>
 8020328:	0004      	movs	r4, r0
 802032a:	4b1a      	ldr	r3, [pc, #104]	@ (8020394 <HAL_InitTick+0x88>)
 802032c:	781b      	ldrb	r3, [r3, #0]
 802032e:	0019      	movs	r1, r3
 8020330:	23fa      	movs	r3, #250	@ 0xfa
 8020332:	0098      	lsls	r0, r3, #2
 8020334:	f7ff fee8 	bl	8020108 <__udivsi3>
 8020338:	0003      	movs	r3, r0
 802033a:	0019      	movs	r1, r3
 802033c:	0020      	movs	r0, r4
 802033e:	f7ff fee3 	bl	8020108 <__udivsi3>
 8020342:	0003      	movs	r3, r0
 8020344:	0018      	movs	r0, r3
 8020346:	f000 f91c 	bl	8020582 <HAL_SYSTICK_Config>
 802034a:	1e03      	subs	r3, r0, #0
 802034c:	d112      	bne.n	8020374 <HAL_InitTick+0x68>
#endif
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 802034e:	687b      	ldr	r3, [r7, #4]
 8020350:	2b0f      	cmp	r3, #15
 8020352:	d80a      	bhi.n	802036a <HAL_InitTick+0x5e>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8020354:	6879      	ldr	r1, [r7, #4]
 8020356:	2301      	movs	r3, #1
 8020358:	425b      	negs	r3, r3
 802035a:	2200      	movs	r2, #0
 802035c:	0018      	movs	r0, r3
 802035e:	f000 f8f1 	bl	8020544 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 8020362:	4b0d      	ldr	r3, [pc, #52]	@ (8020398 <HAL_InitTick+0x8c>)
 8020364:	687a      	ldr	r2, [r7, #4]
 8020366:	601a      	str	r2, [r3, #0]
 8020368:	e00d      	b.n	8020386 <HAL_InitTick+0x7a>
      }
      else
      {
        status = HAL_ERROR;
 802036a:	230f      	movs	r3, #15
 802036c:	18fb      	adds	r3, r7, r3
 802036e:	2201      	movs	r2, #1
 8020370:	701a      	strb	r2, [r3, #0]
 8020372:	e008      	b.n	8020386 <HAL_InitTick+0x7a>
      }
    }
    else
    {
      status = HAL_ERROR;
 8020374:	230f      	movs	r3, #15
 8020376:	18fb      	adds	r3, r7, r3
 8020378:	2201      	movs	r2, #1
 802037a:	701a      	strb	r2, [r3, #0]
 802037c:	e003      	b.n	8020386 <HAL_InitTick+0x7a>
    }
  }
  else
  {
    status = HAL_ERROR;
 802037e:	230f      	movs	r3, #15
 8020380:	18fb      	adds	r3, r7, r3
 8020382:	2201      	movs	r2, #1
 8020384:	701a      	strb	r2, [r3, #0]
  }

  /* Return function status */
  return status;
 8020386:	230f      	movs	r3, #15
 8020388:	18fb      	adds	r3, r7, r3
 802038a:	781b      	ldrb	r3, [r3, #0]
}
 802038c:	0018      	movs	r0, r3
 802038e:	46bd      	mov	sp, r7
 8020390:	b005      	add	sp, #20
 8020392:	bd90      	pop	{r4, r7, pc}
 8020394:	20008008 	.word	0x20008008
 8020398:	20008004 	.word	0x20008004

0802039c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 802039c:	b580      	push	{r7, lr}
 802039e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 80203a0:	4b05      	ldr	r3, [pc, #20]	@ (80203b8 <HAL_IncTick+0x1c>)
 80203a2:	781b      	ldrb	r3, [r3, #0]
 80203a4:	001a      	movs	r2, r3
 80203a6:	4b05      	ldr	r3, [pc, #20]	@ (80203bc <HAL_IncTick+0x20>)
 80203a8:	681b      	ldr	r3, [r3, #0]
 80203aa:	18d2      	adds	r2, r2, r3
 80203ac:	4b03      	ldr	r3, [pc, #12]	@ (80203bc <HAL_IncTick+0x20>)
 80203ae:	601a      	str	r2, [r3, #0]
}
 80203b0:	46c0      	nop			@ (mov r8, r8)
 80203b2:	46bd      	mov	sp, r7
 80203b4:	bd80      	pop	{r7, pc}
 80203b6:	46c0      	nop			@ (mov r8, r8)
 80203b8:	20008008 	.word	0x20008008
 80203bc:	20008028 	.word	0x20008028

080203c0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80203c0:	b580      	push	{r7, lr}
 80203c2:	b084      	sub	sp, #16
 80203c4:	af00      	add	r7, sp, #0
 80203c6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80203c8:	687b      	ldr	r3, [r7, #4]
 80203ca:	2207      	movs	r2, #7
 80203cc:	4013      	ands	r3, r2
 80203ce:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80203d0:	4b0a      	ldr	r3, [pc, #40]	@ (80203fc <__NVIC_SetPriorityGrouping+0x3c>)
 80203d2:	68db      	ldr	r3, [r3, #12]
 80203d4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80203d6:	68bb      	ldr	r3, [r7, #8]
 80203d8:	4a09      	ldr	r2, [pc, #36]	@ (8020400 <__NVIC_SetPriorityGrouping+0x40>)
 80203da:	4013      	ands	r3, r2
 80203dc:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80203de:	68fb      	ldr	r3, [r7, #12]
 80203e0:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80203e2:	68bb      	ldr	r3, [r7, #8]
 80203e4:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80203e6:	4a07      	ldr	r2, [pc, #28]	@ (8020404 <__NVIC_SetPriorityGrouping+0x44>)
 80203e8:	4313      	orrs	r3, r2
 80203ea:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80203ec:	4b03      	ldr	r3, [pc, #12]	@ (80203fc <__NVIC_SetPriorityGrouping+0x3c>)
 80203ee:	68ba      	ldr	r2, [r7, #8]
 80203f0:	60da      	str	r2, [r3, #12]
}
 80203f2:	46c0      	nop			@ (mov r8, r8)
 80203f4:	46bd      	mov	sp, r7
 80203f6:	b004      	add	sp, #16
 80203f8:	bd80      	pop	{r7, pc}
 80203fa:	46c0      	nop			@ (mov r8, r8)
 80203fc:	e000ed00 	.word	0xe000ed00
 8020400:	0000f8ff 	.word	0x0000f8ff
 8020404:	05fa0000 	.word	0x05fa0000

08020408 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8020408:	b580      	push	{r7, lr}
 802040a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 802040c:	4b03      	ldr	r3, [pc, #12]	@ (802041c <__NVIC_GetPriorityGrouping+0x14>)
 802040e:	68db      	ldr	r3, [r3, #12]
 8020410:	0a1b      	lsrs	r3, r3, #8
 8020412:	2207      	movs	r2, #7
 8020414:	4013      	ands	r3, r2
}
 8020416:	0018      	movs	r0, r3
 8020418:	46bd      	mov	sp, r7
 802041a:	bd80      	pop	{r7, pc}
 802041c:	e000ed00 	.word	0xe000ed00

08020420 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8020420:	b580      	push	{r7, lr}
 8020422:	b082      	sub	sp, #8
 8020424:	af00      	add	r7, sp, #0
 8020426:	0002      	movs	r2, r0
 8020428:	6039      	str	r1, [r7, #0]
 802042a:	1dfb      	adds	r3, r7, #7
 802042c:	701a      	strb	r2, [r3, #0]
  if ((int32_t)(IRQn) >= 0)
 802042e:	1dfb      	adds	r3, r7, #7
 8020430:	781b      	ldrb	r3, [r3, #0]
 8020432:	2b7f      	cmp	r3, #127	@ 0x7f
 8020434:	d80e      	bhi.n	8020454 <__NVIC_SetPriority+0x34>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8020436:	683b      	ldr	r3, [r7, #0]
 8020438:	b2db      	uxtb	r3, r3
 802043a:	490f      	ldr	r1, [pc, #60]	@ (8020478 <__NVIC_SetPriority+0x58>)
 802043c:	1dfa      	adds	r2, r7, #7
 802043e:	7812      	ldrb	r2, [r2, #0]
 8020440:	b252      	sxtb	r2, r2
 8020442:	011b      	lsls	r3, r3, #4
 8020444:	b2d8      	uxtb	r0, r3
 8020446:	23c0      	movs	r3, #192	@ 0xc0
 8020448:	009b      	lsls	r3, r3, #2
 802044a:	188a      	adds	r2, r1, r2
 802044c:	18d3      	adds	r3, r2, r3
 802044e:	1c02      	adds	r2, r0, #0
 8020450:	701a      	strb	r2, [r3, #0]
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8020452:	e00c      	b.n	802046e <__NVIC_SetPriority+0x4e>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8020454:	683b      	ldr	r3, [r7, #0]
 8020456:	b2da      	uxtb	r2, r3
 8020458:	4908      	ldr	r1, [pc, #32]	@ (802047c <__NVIC_SetPriority+0x5c>)
 802045a:	1dfb      	adds	r3, r7, #7
 802045c:	781b      	ldrb	r3, [r3, #0]
 802045e:	0018      	movs	r0, r3
 8020460:	230f      	movs	r3, #15
 8020462:	4003      	ands	r3, r0
 8020464:	3b04      	subs	r3, #4
 8020466:	0112      	lsls	r2, r2, #4
 8020468:	b2d2      	uxtb	r2, r2
 802046a:	18cb      	adds	r3, r1, r3
 802046c:	761a      	strb	r2, [r3, #24]
}
 802046e:	46c0      	nop			@ (mov r8, r8)
 8020470:	46bd      	mov	sp, r7
 8020472:	b002      	add	sp, #8
 8020474:	bd80      	pop	{r7, pc}
 8020476:	46c0      	nop			@ (mov r8, r8)
 8020478:	e000e100 	.word	0xe000e100
 802047c:	e000ed00 	.word	0xe000ed00

08020480 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8020480:	b580      	push	{r7, lr}
 8020482:	b088      	sub	sp, #32
 8020484:	af00      	add	r7, sp, #0
 8020486:	60f8      	str	r0, [r7, #12]
 8020488:	60b9      	str	r1, [r7, #8]
 802048a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 802048c:	68fb      	ldr	r3, [r7, #12]
 802048e:	2207      	movs	r2, #7
 8020490:	4013      	ands	r3, r2
 8020492:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8020494:	69fb      	ldr	r3, [r7, #28]
 8020496:	2207      	movs	r2, #7
 8020498:	1ad3      	subs	r3, r2, r3
 802049a:	2b04      	cmp	r3, #4
 802049c:	d900      	bls.n	80204a0 <NVIC_EncodePriority+0x20>
 802049e:	2304      	movs	r3, #4
 80204a0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80204a2:	69fb      	ldr	r3, [r7, #28]
 80204a4:	3304      	adds	r3, #4
 80204a6:	2b06      	cmp	r3, #6
 80204a8:	d902      	bls.n	80204b0 <NVIC_EncodePriority+0x30>
 80204aa:	69fb      	ldr	r3, [r7, #28]
 80204ac:	3b03      	subs	r3, #3
 80204ae:	e000      	b.n	80204b2 <NVIC_EncodePriority+0x32>
 80204b0:	2300      	movs	r3, #0
 80204b2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80204b4:	2301      	movs	r3, #1
 80204b6:	425a      	negs	r2, r3
 80204b8:	69bb      	ldr	r3, [r7, #24]
 80204ba:	409a      	lsls	r2, r3
 80204bc:	0013      	movs	r3, r2
 80204be:	43db      	mvns	r3, r3
 80204c0:	68ba      	ldr	r2, [r7, #8]
 80204c2:	401a      	ands	r2, r3
 80204c4:	697b      	ldr	r3, [r7, #20]
 80204c6:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80204c8:	2301      	movs	r3, #1
 80204ca:	4259      	negs	r1, r3
 80204cc:	697b      	ldr	r3, [r7, #20]
 80204ce:	4099      	lsls	r1, r3
 80204d0:	000b      	movs	r3, r1
 80204d2:	43db      	mvns	r3, r3
 80204d4:	6879      	ldr	r1, [r7, #4]
 80204d6:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80204d8:	4313      	orrs	r3, r2
         );
}
 80204da:	0018      	movs	r0, r3
 80204dc:	46bd      	mov	sp, r7
 80204de:	b008      	add	sp, #32
 80204e0:	bd80      	pop	{r7, pc}
	...

080204e4 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 80204e4:	b580      	push	{r7, lr}
 80204e6:	b082      	sub	sp, #8
 80204e8:	af00      	add	r7, sp, #0
 80204ea:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80204ec:	687b      	ldr	r3, [r7, #4]
 80204ee:	1e5a      	subs	r2, r3, #1
 80204f0:	2380      	movs	r3, #128	@ 0x80
 80204f2:	045b      	lsls	r3, r3, #17
 80204f4:	429a      	cmp	r2, r3
 80204f6:	d301      	bcc.n	80204fc <SysTick_Config+0x18>
  {
    return (1UL);                                                   /* Reload value impossible */
 80204f8:	2301      	movs	r3, #1
 80204fa:	e010      	b.n	802051e <SysTick_Config+0x3a>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80204fc:	4b0a      	ldr	r3, [pc, #40]	@ (8020528 <SysTick_Config+0x44>)
 80204fe:	687a      	ldr	r2, [r7, #4]
 8020500:	3a01      	subs	r2, #1
 8020502:	605a      	str	r2, [r3, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8020504:	2301      	movs	r3, #1
 8020506:	425b      	negs	r3, r3
 8020508:	210f      	movs	r1, #15
 802050a:	0018      	movs	r0, r3
 802050c:	f7ff ff88 	bl	8020420 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8020510:	4b05      	ldr	r3, [pc, #20]	@ (8020528 <SysTick_Config+0x44>)
 8020512:	2200      	movs	r2, #0
 8020514:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8020516:	4b04      	ldr	r3, [pc, #16]	@ (8020528 <SysTick_Config+0x44>)
 8020518:	2207      	movs	r2, #7
 802051a:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 802051c:	2300      	movs	r3, #0
}
 802051e:	0018      	movs	r0, r3
 8020520:	46bd      	mov	sp, r7
 8020522:	b002      	add	sp, #8
 8020524:	bd80      	pop	{r7, pc}
 8020526:	46c0      	nop			@ (mov r8, r8)
 8020528:	e000e010 	.word	0xe000e010

0802052c <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 802052c:	b580      	push	{r7, lr}
 802052e:	b082      	sub	sp, #8
 8020530:	af00      	add	r7, sp, #0
 8020532:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8020534:	687b      	ldr	r3, [r7, #4]
 8020536:	0018      	movs	r0, r3
 8020538:	f7ff ff42 	bl	80203c0 <__NVIC_SetPriorityGrouping>
}
 802053c:	46c0      	nop			@ (mov r8, r8)
 802053e:	46bd      	mov	sp, r7
 8020540:	b002      	add	sp, #8
 8020542:	bd80      	pop	{r7, pc}

08020544 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8020544:	b590      	push	{r4, r7, lr}
 8020546:	b087      	sub	sp, #28
 8020548:	af00      	add	r7, sp, #0
 802054a:	60b9      	str	r1, [r7, #8]
 802054c:	607a      	str	r2, [r7, #4]
 802054e:	240f      	movs	r4, #15
 8020550:	193b      	adds	r3, r7, r4
 8020552:	1c02      	adds	r2, r0, #0
 8020554:	701a      	strb	r2, [r3, #0]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8020556:	f7ff ff57 	bl	8020408 <__NVIC_GetPriorityGrouping>
 802055a:	0003      	movs	r3, r0
 802055c:	617b      	str	r3, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 802055e:	687a      	ldr	r2, [r7, #4]
 8020560:	68b9      	ldr	r1, [r7, #8]
 8020562:	697b      	ldr	r3, [r7, #20]
 8020564:	0018      	movs	r0, r3
 8020566:	f7ff ff8b 	bl	8020480 <NVIC_EncodePriority>
 802056a:	0002      	movs	r2, r0
 802056c:	193b      	adds	r3, r7, r4
 802056e:	781b      	ldrb	r3, [r3, #0]
 8020570:	b25b      	sxtb	r3, r3
 8020572:	0011      	movs	r1, r2
 8020574:	0018      	movs	r0, r3
 8020576:	f7ff ff53 	bl	8020420 <__NVIC_SetPriority>
}
 802057a:	46c0      	nop			@ (mov r8, r8)
 802057c:	46bd      	mov	sp, r7
 802057e:	b007      	add	sp, #28
 8020580:	bd90      	pop	{r4, r7, pc}

08020582 <HAL_SYSTICK_Config>:
  * @param TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8020582:	b580      	push	{r7, lr}
 8020584:	b082      	sub	sp, #8
 8020586:	af00      	add	r7, sp, #0
 8020588:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
 802058a:	687b      	ldr	r3, [r7, #4]
 802058c:	0018      	movs	r0, r3
 802058e:	f7ff ffa9 	bl	80204e4 <SysTick_Config>
 8020592:	0003      	movs	r3, r0
}
 8020594:	0018      	movs	r0, r3
 8020596:	46bd      	mov	sp, r7
 8020598:	b002      	add	sp, #8
 802059a:	bd80      	pop	{r7, pc}

0802059c <LL_RCC_HSE_IsEnabledDiv2>:
  * @brief  Get HSE sysclk and pll prescaler  division by 2
  * @rmtoll CR           HSEPRE        LL_RCC_HSE_IsEnabledDiv2
  * @retval None
  */
__STATIC_INLINE uint32_t LL_RCC_HSE_IsEnabledDiv2(void)
{
 802059c:	b580      	push	{r7, lr}
 802059e:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_HSEPRE) == (RCC_CR_HSEPRE)) ? 1UL : 0UL);
 80205a0:	23b0      	movs	r3, #176	@ 0xb0
 80205a2:	05db      	lsls	r3, r3, #23
 80205a4:	681a      	ldr	r2, [r3, #0]
 80205a6:	2380      	movs	r3, #128	@ 0x80
 80205a8:	035b      	lsls	r3, r3, #13
 80205aa:	401a      	ands	r2, r3
 80205ac:	2380      	movs	r3, #128	@ 0x80
 80205ae:	035b      	lsls	r3, r3, #13
 80205b0:	429a      	cmp	r2, r3
 80205b2:	d101      	bne.n	80205b8 <LL_RCC_HSE_IsEnabledDiv2+0x1c>
 80205b4:	2301      	movs	r3, #1
 80205b6:	e000      	b.n	80205ba <LL_RCC_HSE_IsEnabledDiv2+0x1e>
 80205b8:	2300      	movs	r3, #0
}
 80205ba:	0018      	movs	r0, r3
 80205bc:	46bd      	mov	sp, r7
 80205be:	bd80      	pop	{r7, pc}

080205c0 <LL_RCC_MSI_IsEnabledRangeSelect>:
  * @brief  Check if MSI clock range is selected with MSIRANGE register
  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_IsEnabledRangeSelect
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
{
 80205c0:	b580      	push	{r7, lr}
 80205c2:	af00      	add	r7, sp, #0
  return ((READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL)) ? 1UL : 0UL);
 80205c4:	23b0      	movs	r3, #176	@ 0xb0
 80205c6:	05db      	lsls	r3, r3, #23
 80205c8:	681b      	ldr	r3, [r3, #0]
 80205ca:	2208      	movs	r2, #8
 80205cc:	4013      	ands	r3, r2
 80205ce:	2b08      	cmp	r3, #8
 80205d0:	d101      	bne.n	80205d6 <LL_RCC_MSI_IsEnabledRangeSelect+0x16>
 80205d2:	2301      	movs	r3, #1
 80205d4:	e000      	b.n	80205d8 <LL_RCC_MSI_IsEnabledRangeSelect+0x18>
 80205d6:	2300      	movs	r3, #0
}
 80205d8:	0018      	movs	r0, r3
 80205da:	46bd      	mov	sp, r7
 80205dc:	bd80      	pop	{r7, pc}

080205de <LL_RCC_MSI_GetRange>:
  *         @arg @ref LL_RCC_MSIRANGE_9
  *         @arg @ref LL_RCC_MSIRANGE_10
  *         @arg @ref LL_RCC_MSIRANGE_11
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetRange(void)
{
 80205de:	b580      	push	{r7, lr}
 80205e0:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 80205e2:	23b0      	movs	r3, #176	@ 0xb0
 80205e4:	05db      	lsls	r3, r3, #23
 80205e6:	681b      	ldr	r3, [r3, #0]
 80205e8:	22f0      	movs	r2, #240	@ 0xf0
 80205ea:	4013      	ands	r3, r2
}
 80205ec:	0018      	movs	r0, r3
 80205ee:	46bd      	mov	sp, r7
 80205f0:	bd80      	pop	{r7, pc}

080205f2 <LL_RCC_MSI_GetRangeAfterStandby>:
  *         @arg @ref LL_RCC_MSISRANGE_5
  *         @arg @ref LL_RCC_MSISRANGE_6
  *         @arg @ref LL_RCC_MSISRANGE_7
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_GetRangeAfterStandby(void)
{
 80205f2:	b580      	push	{r7, lr}
 80205f4:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 80205f6:	23b0      	movs	r3, #176	@ 0xb0
 80205f8:	05db      	lsls	r3, r3, #23
 80205fa:	2294      	movs	r2, #148	@ 0x94
 80205fc:	589a      	ldr	r2, [r3, r2]
 80205fe:	23f0      	movs	r3, #240	@ 0xf0
 8020600:	011b      	lsls	r3, r3, #4
 8020602:	4013      	ands	r3, r2
}
 8020604:	0018      	movs	r0, r3
 8020606:	46bd      	mov	sp, r7
 8020608:	bd80      	pop	{r7, pc}

0802060a <LL_RCC_GetSysClkSource>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_HSE
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_PLL
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
 802060a:	b580      	push	{r7, lr}
 802060c:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 802060e:	23b0      	movs	r3, #176	@ 0xb0
 8020610:	05db      	lsls	r3, r3, #23
 8020612:	689b      	ldr	r3, [r3, #8]
 8020614:	220c      	movs	r2, #12
 8020616:	4013      	ands	r3, r2
}
 8020618:	0018      	movs	r0, r3
 802061a:	46bd      	mov	sp, r7
 802061c:	bd80      	pop	{r7, pc}

0802061e <LL_RCC_GetAHBPrescaler>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_128
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
 802061e:	b580      	push	{r7, lr}
 8020620:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8020622:	23b0      	movs	r3, #176	@ 0xb0
 8020624:	05db      	lsls	r3, r3, #23
 8020626:	689b      	ldr	r3, [r3, #8]
 8020628:	22f0      	movs	r2, #240	@ 0xf0
 802062a:	4013      	ands	r3, r2
}
 802062c:	0018      	movs	r0, r3
 802062e:	46bd      	mov	sp, r7
 8020630:	bd80      	pop	{r7, pc}

08020632 <LL_RCC_PLL_GetN>:
  * @brief  Get Main PLL multiplication factor for VCO
  * @rmtoll PLLCFGR      PLLN          LL_RCC_PLL_GetN
  * @retval Between 6 and 127
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
{
 8020632:	b580      	push	{r7, lr}
 8020634:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8020636:	23b0      	movs	r3, #176	@ 0xb0
 8020638:	05db      	lsls	r3, r3, #23
 802063a:	68db      	ldr	r3, [r3, #12]
 802063c:	0a1b      	lsrs	r3, r3, #8
 802063e:	227f      	movs	r2, #127	@ 0x7f
 8020640:	4013      	ands	r3, r2
}
 8020642:	0018      	movs	r0, r3
 8020644:	46bd      	mov	sp, r7
 8020646:	bd80      	pop	{r7, pc}

08020648 <LL_RCC_PLL_GetR>:
  *         @arg @ref LL_RCC_PLLR_DIV_6
  *         @arg @ref LL_RCC_PLLR_DIV_7
  *         @arg @ref LL_RCC_PLLR_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetR(void)
{
 8020648:	b580      	push	{r7, lr}
 802064a:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 802064c:	23b0      	movs	r3, #176	@ 0xb0
 802064e:	05db      	lsls	r3, r3, #23
 8020650:	68db      	ldr	r3, [r3, #12]
 8020652:	0f5b      	lsrs	r3, r3, #29
 8020654:	075b      	lsls	r3, r3, #29
}
 8020656:	0018      	movs	r0, r3
 8020658:	46bd      	mov	sp, r7
 802065a:	bd80      	pop	{r7, pc}

0802065c <LL_RCC_PLL_GetDivider>:
  *         @arg @ref LL_RCC_PLLM_DIV_6
  *         @arg @ref LL_RCC_PLLM_DIV_7
  *         @arg @ref LL_RCC_PLLM_DIV_8
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
 802065c:	b580      	push	{r7, lr}
 802065e:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8020660:	23b0      	movs	r3, #176	@ 0xb0
 8020662:	05db      	lsls	r3, r3, #23
 8020664:	68db      	ldr	r3, [r3, #12]
 8020666:	2270      	movs	r2, #112	@ 0x70
 8020668:	4013      	ands	r3, r2
}
 802066a:	0018      	movs	r0, r3
 802066c:	46bd      	mov	sp, r7
 802066e:	bd80      	pop	{r7, pc}

08020670 <LL_RCC_PLL_GetMainSource>:
  *         @arg @ref LL_RCC_PLLSOURCE_MSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
 8020670:	b580      	push	{r7, lr}
 8020672:	af00      	add	r7, sp, #0
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8020674:	23b0      	movs	r3, #176	@ 0xb0
 8020676:	05db      	lsls	r3, r3, #23
 8020678:	68db      	ldr	r3, [r3, #12]
 802067a:	2203      	movs	r2, #3
 802067c:	4013      	ands	r3, r2
}
 802067e:	0018      	movs	r0, r3
 8020680:	46bd      	mov	sp, r7
 8020682:	bd80      	pop	{r7, pc}

08020684 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8020684:	b590      	push	{r4, r7, lr}
 8020686:	b087      	sub	sp, #28
 8020688:	af00      	add	r7, sp, #0
  uint32_t sysclk_source;
  uint32_t pllsource;
  uint32_t sysclockfreq = 0U;
 802068a:	2300      	movs	r3, #0
 802068c:	617b      	str	r3, [r7, #20]
  uint32_t msifreq = 0U;
 802068e:	2300      	movs	r3, #0
 8020690:	613b      	str	r3, [r7, #16]
  uint32_t pllinputfreq;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8020692:	f7ff ffba 	bl	802060a <LL_RCC_GetSysClkSource>
 8020696:	0003      	movs	r3, r0
 8020698:	60bb      	str	r3, [r7, #8]
  pllsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 802069a:	f7ff ffe9 	bl	8020670 <LL_RCC_PLL_GetMainSource>
 802069e:	0003      	movs	r3, r0
 80206a0:	607b      	str	r3, [r7, #4]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 80206a2:	68bb      	ldr	r3, [r7, #8]
 80206a4:	2b00      	cmp	r3, #0
 80206a6:	d005      	beq.n	80206b4 <HAL_RCC_GetSysClockFreq+0x30>
 80206a8:	68bb      	ldr	r3, [r7, #8]
 80206aa:	2b0c      	cmp	r3, #12
 80206ac:	d138      	bne.n	8020720 <HAL_RCC_GetSysClockFreq+0x9c>
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pllsource == RCC_PLLSOURCE_MSI)))
 80206ae:	687b      	ldr	r3, [r7, #4]
 80206b0:	2b01      	cmp	r3, #1
 80206b2:	d135      	bne.n	8020720 <HAL_RCC_GetSysClockFreq+0x9c>
  {
    /* MSI or PLL with MSI source used as system clock source */
    /* Retrieve MSI frequency range in Hz */
    msifreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 80206b4:	f7ff ff84 	bl	80205c0 <LL_RCC_MSI_IsEnabledRangeSelect>
 80206b8:	1e03      	subs	r3, r0, #0
 80206ba:	d115      	bne.n	80206e8 <HAL_RCC_GetSysClockFreq+0x64>
 80206bc:	f7ff ff80 	bl	80205c0 <LL_RCC_MSI_IsEnabledRangeSelect>
 80206c0:	0003      	movs	r3, r0
 80206c2:	2b01      	cmp	r3, #1
 80206c4:	d106      	bne.n	80206d4 <HAL_RCC_GetSysClockFreq+0x50>
 80206c6:	f7ff ff8a 	bl	80205de <LL_RCC_MSI_GetRange>
 80206ca:	0003      	movs	r3, r0
 80206cc:	0a1b      	lsrs	r3, r3, #8
 80206ce:	220f      	movs	r2, #15
 80206d0:	4013      	ands	r3, r2
 80206d2:	e005      	b.n	80206e0 <HAL_RCC_GetSysClockFreq+0x5c>
 80206d4:	f7ff ff8d 	bl	80205f2 <LL_RCC_MSI_GetRangeAfterStandby>
 80206d8:	0003      	movs	r3, r0
 80206da:	0a1b      	lsrs	r3, r3, #8
 80206dc:	220f      	movs	r2, #15
 80206de:	4013      	ands	r3, r2
 80206e0:	4a3a      	ldr	r2, [pc, #232]	@ (80207cc <HAL_RCC_GetSysClockFreq+0x148>)
 80206e2:	009b      	lsls	r3, r3, #2
 80206e4:	589b      	ldr	r3, [r3, r2]
 80206e6:	e014      	b.n	8020712 <HAL_RCC_GetSysClockFreq+0x8e>
 80206e8:	f7ff ff6a 	bl	80205c0 <LL_RCC_MSI_IsEnabledRangeSelect>
 80206ec:	0003      	movs	r3, r0
 80206ee:	2b01      	cmp	r3, #1
 80206f0:	d106      	bne.n	8020700 <HAL_RCC_GetSysClockFreq+0x7c>
 80206f2:	f7ff ff74 	bl	80205de <LL_RCC_MSI_GetRange>
 80206f6:	0003      	movs	r3, r0
 80206f8:	091b      	lsrs	r3, r3, #4
 80206fa:	220f      	movs	r2, #15
 80206fc:	4013      	ands	r3, r2
 80206fe:	e005      	b.n	802070c <HAL_RCC_GetSysClockFreq+0x88>
 8020700:	f7ff ff77 	bl	80205f2 <LL_RCC_MSI_GetRangeAfterStandby>
 8020704:	0003      	movs	r3, r0
 8020706:	091b      	lsrs	r3, r3, #4
 8020708:	220f      	movs	r2, #15
 802070a:	4013      	ands	r3, r2
 802070c:	4a2f      	ldr	r2, [pc, #188]	@ (80207cc <HAL_RCC_GetSysClockFreq+0x148>)
 802070e:	009b      	lsls	r3, r3, #2
 8020710:	589b      	ldr	r3, [r3, r2]
 8020712:	613b      	str	r3, [r7, #16]
                                     ((LL_RCC_MSI_IsEnabledRangeSelect() == 1U) ?
                                      LL_RCC_MSI_GetRange() :
                                      LL_RCC_MSI_GetRangeAfterStandby()));

    /* Get SYSCLK source */
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 8020714:	68bb      	ldr	r3, [r7, #8]
 8020716:	2b00      	cmp	r3, #0
 8020718:	d115      	bne.n	8020746 <HAL_RCC_GetSysClockFreq+0xc2>
    {
      /* MSI used as system clock source */
      sysclockfreq = msifreq;
 802071a:	693b      	ldr	r3, [r7, #16]
 802071c:	617b      	str	r3, [r7, #20]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 802071e:	e012      	b.n	8020746 <HAL_RCC_GetSysClockFreq+0xc2>
    }
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 8020720:	68bb      	ldr	r3, [r7, #8]
 8020722:	2b04      	cmp	r3, #4
 8020724:	d102      	bne.n	802072c <HAL_RCC_GetSysClockFreq+0xa8>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
 8020726:	4b2a      	ldr	r3, [pc, #168]	@ (80207d0 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020728:	617b      	str	r3, [r7, #20]
 802072a:	e00c      	b.n	8020746 <HAL_RCC_GetSysClockFreq+0xc2>
  }
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 802072c:	68bb      	ldr	r3, [r7, #8]
 802072e:	2b08      	cmp	r3, #8
 8020730:	d109      	bne.n	8020746 <HAL_RCC_GetSysClockFreq+0xc2>
  {
    /* HSE used as system clock source */
    if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 8020732:	f7ff ff33 	bl	802059c <LL_RCC_HSE_IsEnabledDiv2>
 8020736:	0003      	movs	r3, r0
 8020738:	2b01      	cmp	r3, #1
 802073a:	d102      	bne.n	8020742 <HAL_RCC_GetSysClockFreq+0xbe>
    {
      sysclockfreq = HSE_VALUE / 2U;
 802073c:	4b24      	ldr	r3, [pc, #144]	@ (80207d0 <HAL_RCC_GetSysClockFreq+0x14c>)
 802073e:	617b      	str	r3, [r7, #20]
 8020740:	e001      	b.n	8020746 <HAL_RCC_GetSysClockFreq+0xc2>
    }
    else
    {
      sysclockfreq = HSE_VALUE;
 8020742:	4b24      	ldr	r3, [pc, #144]	@ (80207d4 <HAL_RCC_GetSysClockFreq+0x150>)
 8020744:	617b      	str	r3, [r7, #20]
  else
  {
    /* Nothing to do */
  }

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8020746:	f7ff ff60 	bl	802060a <LL_RCC_GetSysClkSource>
 802074a:	0003      	movs	r3, r0
 802074c:	2b0c      	cmp	r3, #12
 802074e:	d137      	bne.n	80207c0 <HAL_RCC_GetSysClockFreq+0x13c>
  {
    /* PLL used as system clock  source */
    pllsource = LL_RCC_PLL_GetMainSource();
 8020750:	f7ff ff8e 	bl	8020670 <LL_RCC_PLL_GetMainSource>
 8020754:	0003      	movs	r3, r0
 8020756:	607b      	str	r3, [r7, #4]

    switch (pllsource)
 8020758:	687b      	ldr	r3, [r7, #4]
 802075a:	2b02      	cmp	r3, #2
 802075c:	d003      	beq.n	8020766 <HAL_RCC_GetSysClockFreq+0xe2>
 802075e:	687b      	ldr	r3, [r7, #4]
 8020760:	2b03      	cmp	r3, #3
 8020762:	d003      	beq.n	802076c <HAL_RCC_GetSysClockFreq+0xe8>
 8020764:	e00d      	b.n	8020782 <HAL_RCC_GetSysClockFreq+0xfe>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
        pllinputfreq = HSI_VALUE;
 8020766:	4b1a      	ldr	r3, [pc, #104]	@ (80207d0 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020768:	60fb      	str	r3, [r7, #12]
        break;
 802076a:	e00d      	b.n	8020788 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        if (LL_RCC_HSE_IsEnabledDiv2() == 1U)
 802076c:	f7ff ff16 	bl	802059c <LL_RCC_HSE_IsEnabledDiv2>
 8020770:	0003      	movs	r3, r0
 8020772:	2b01      	cmp	r3, #1
 8020774:	d102      	bne.n	802077c <HAL_RCC_GetSysClockFreq+0xf8>
        {
          pllinputfreq = HSE_VALUE / 2U;
 8020776:	4b16      	ldr	r3, [pc, #88]	@ (80207d0 <HAL_RCC_GetSysClockFreq+0x14c>)
 8020778:	60fb      	str	r3, [r7, #12]
        }
        else
        {
          pllinputfreq = HSE_VALUE;
        }
        break;
 802077a:	e005      	b.n	8020788 <HAL_RCC_GetSysClockFreq+0x104>
          pllinputfreq = HSE_VALUE;
 802077c:	4b15      	ldr	r3, [pc, #84]	@ (80207d4 <HAL_RCC_GetSysClockFreq+0x150>)
 802077e:	60fb      	str	r3, [r7, #12]
        break;
 8020780:	e002      	b.n	8020788 <HAL_RCC_GetSysClockFreq+0x104>
      case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
      default:
        pllinputfreq = msifreq;
 8020782:	693b      	ldr	r3, [r7, #16]
 8020784:	60fb      	str	r3, [r7, #12]
        break;
 8020786:	46c0      	nop			@ (mov r8, r8)
    }
    sysclockfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8020788:	f7ff ff53 	bl	8020632 <LL_RCC_PLL_GetN>
 802078c:	0002      	movs	r2, r0
 802078e:	68fb      	ldr	r3, [r7, #12]
 8020790:	4353      	muls	r3, r2
 8020792:	001c      	movs	r4, r3
 8020794:	f7ff ff62 	bl	802065c <LL_RCC_PLL_GetDivider>
 8020798:	0003      	movs	r3, r0
 802079a:	091b      	lsrs	r3, r3, #4
 802079c:	3301      	adds	r3, #1
 802079e:	0019      	movs	r1, r3
 80207a0:	0020      	movs	r0, r4
 80207a2:	f7ff fcb1 	bl	8020108 <__udivsi3>
 80207a6:	0003      	movs	r3, r0
 80207a8:	001c      	movs	r4, r3
 80207aa:	f7ff ff4d 	bl	8020648 <LL_RCC_PLL_GetR>
 80207ae:	0003      	movs	r3, r0
 80207b0:	0f5b      	lsrs	r3, r3, #29
 80207b2:	3301      	adds	r3, #1
 80207b4:	0019      	movs	r1, r3
 80207b6:	0020      	movs	r0, r4
 80207b8:	f7ff fca6 	bl	8020108 <__udivsi3>
 80207bc:	0003      	movs	r3, r0
 80207be:	617b      	str	r3, [r7, #20]
                                             LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
  }

  return sysclockfreq;
 80207c0:	697b      	ldr	r3, [r7, #20]
}
 80207c2:	0018      	movs	r0, r3
 80207c4:	46bd      	mov	sp, r7
 80207c6:	b007      	add	sp, #28
 80207c8:	bd90      	pop	{r4, r7, pc}
 80207ca:	46c0      	nop			@ (mov r8, r8)
 80207cc:	080208a8 	.word	0x080208a8
 80207d0:	00f42400 	.word	0x00f42400
 80207d4:	01e84800 	.word	0x01e84800

080207d8 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80207d8:	b5b0      	push	{r4, r5, r7, lr}
 80207da:	af00      	add	r7, sp, #0
  /* Get SysClock and Compute HCLK1 frequency --------------------------------*/
  return ((uint32_t)(__LL_RCC_CALC_HCLK1_FREQ(HAL_RCC_GetSysClockFreq(), LL_RCC_GetAHBPrescaler())));
 80207dc:	f7ff ff52 	bl	8020684 <HAL_RCC_GetSysClockFreq>
 80207e0:	0004      	movs	r4, r0
 80207e2:	f7ff ff1c 	bl	802061e <LL_RCC_GetAHBPrescaler>
 80207e6:	0003      	movs	r3, r0
 80207e8:	091b      	lsrs	r3, r3, #4
 80207ea:	220f      	movs	r2, #15
 80207ec:	401a      	ands	r2, r3
 80207ee:	4b05      	ldr	r3, [pc, #20]	@ (8020804 <HAL_RCC_GetHCLKFreq+0x2c>)
 80207f0:	0092      	lsls	r2, r2, #2
 80207f2:	58d3      	ldr	r3, [r2, r3]
 80207f4:	0019      	movs	r1, r3
 80207f6:	0020      	movs	r0, r4
 80207f8:	f7ff fc86 	bl	8020108 <__udivsi3>
 80207fc:	0003      	movs	r3, r0
}
 80207fe:	0018      	movs	r0, r3
 8020800:	46bd      	mov	sp, r7
 8020802:	bdb0      	pop	{r4, r5, r7, pc}
 8020804:	08020868 	.word	0x08020868

08020808 <__libc_init_array>:
 8020808:	b570      	push	{r4, r5, r6, lr}
 802080a:	2600      	movs	r6, #0
 802080c:	4c0c      	ldr	r4, [pc, #48]	@ (8020840 <__libc_init_array+0x38>)
 802080e:	4d0d      	ldr	r5, [pc, #52]	@ (8020844 <__libc_init_array+0x3c>)
 8020810:	1b64      	subs	r4, r4, r5
 8020812:	10a4      	asrs	r4, r4, #2
 8020814:	42a6      	cmp	r6, r4
 8020816:	d109      	bne.n	802082c <__libc_init_array+0x24>
 8020818:	2600      	movs	r6, #0
 802081a:	f000 f819 	bl	8020850 <_init>
 802081e:	4c0a      	ldr	r4, [pc, #40]	@ (8020848 <__libc_init_array+0x40>)
 8020820:	4d0a      	ldr	r5, [pc, #40]	@ (802084c <__libc_init_array+0x44>)
 8020822:	1b64      	subs	r4, r4, r5
 8020824:	10a4      	asrs	r4, r4, #2
 8020826:	42a6      	cmp	r6, r4
 8020828:	d105      	bne.n	8020836 <__libc_init_array+0x2e>
 802082a:	bd70      	pop	{r4, r5, r6, pc}
 802082c:	00b3      	lsls	r3, r6, #2
 802082e:	58eb      	ldr	r3, [r5, r3]
 8020830:	4798      	blx	r3
 8020832:	3601      	adds	r6, #1
 8020834:	e7ee      	b.n	8020814 <__libc_init_array+0xc>
 8020836:	00b3      	lsls	r3, r6, #2
 8020838:	58eb      	ldr	r3, [r5, r3]
 802083a:	4798      	blx	r3
 802083c:	3601      	adds	r6, #1
 802083e:	e7f2      	b.n	8020826 <__libc_init_array+0x1e>
 8020840:	080208e8 	.word	0x080208e8
 8020844:	080208e8 	.word	0x080208e8
 8020848:	080208ec 	.word	0x080208ec
 802084c:	080208e8 	.word	0x080208e8

08020850 <_init>:
 8020850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8020852:	46c0      	nop			@ (mov r8, r8)
 8020854:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8020856:	bc08      	pop	{r3}
 8020858:	469e      	mov	lr, r3
 802085a:	4770      	bx	lr

0802085c <_fini>:
 802085c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802085e:	46c0      	nop			@ (mov r8, r8)
 8020860:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8020862:	bc08      	pop	{r3}
 8020864:	469e      	mov	lr, r3
 8020866:	4770      	bx	lr
